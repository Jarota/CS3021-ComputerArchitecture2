	T4 Answers

----------------------------------------

Q1.
i)	add	r1, r1, r2
	nop	 -   -   -
	add	r3, r1, r3

ii)	addi	r1, r1, 03
 	addi	r2, r2, 03
	add	r3, r1, r2

iii)	addi	r1, r1, 05
	st	r1, r0, 00

iv)	addi	r0, r0, 05

v)	ld	r0, r1, 00

vi)	addi	r0, r0, 01
	beqz	 -  r0, 08

vii)	jr	 -   -  r0

viii)	j		04
	j		FC

----------------------------------------

Q2.
i)	r1:		0x15
	clk cycles:	10

ii)	r1:		0x15
	clk cycles:	18

iii)	r1:		0x06
	clk cycles:	10

With ALU forwarding on, there are no stalls
needed for this program, hence the number of
clock cycles stays at 10, however r1 still has
the 'correct' result at the end (0x15). With
no ALU forwarding, but with CPU data dependency
interlocks, the same 'correct' result is gotten,
but stalls were needed in order to have the
right values in r1 and r2 at each stage. Without
ALU forwarding or interlocks, the program only
takes 10 clock cycles again, but a different
result is in r1 at the end, because the data
dependencies were essentially ignored.
